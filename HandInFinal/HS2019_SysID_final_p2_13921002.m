function [p2_a_ex1, p2_b_ex1,p2_a_ex2, p2_b_ex2, p2_mse_ex1, p2_mse_ex2] = HS2019_SysID_final_p2_13921002()
%% Solution for Problem 1

%% Generate data

% Extract Legi from Filename
name=mfilename;
LegiNumber= name(end-7:end);

% generate data
[p2_u1,p2_u2,p2_u_cv,p2_y1,p2_y2,p2_y_cv] = HS2019_SysID_final_p2_GenerateData(LegiNumber);

%% General instructions for solution

% Change the filename of this function, both in the function definition
% above and in the filename in the folder

% Use the variables p2_y and p2_u to solve the problem. 

% Modify your code in the next sections, and return the variables
% requested.

% If you skip one part of the problem, return the empty vectors as already
% provided in the code

%% Part 1
% Compute parameter estimates using instruments generated by least squares
% regression of the data
fprintf("------------------------------------------------------------------\n")
fprintf("------------------------------------------------------------------\n")
fprintf("------------------------------------------------------------------\n")
fprintf("\n")
fprintf("*** Problem 2 ***\n")
fprintf("\n")

fprintf("------------------------------------------------------------------\n")
fprintf("------------------------------------------------------------------\n")
fprintf("\n")
fprintf("Task 1:\n")
fprintf("\n")

fprintf("The least squares estimate is unbiased, since the configuration\n")
fprintf("assumed for the model is right (ARX) and noise has zero mean.\n")
fprintf("The instrumental variables estimates are also unbiased, since the\n")
fprintf("'unbias' would be lost if the instruments were correlated with the\n")
fprintf("noise and this is not the case since they are computed with u_2.\n")
fprintf("The other cases where 'unbias' is lost are displayed in slide 11.34,\n")
fprintf("but they are also not the case in this system.\n")
fprintf("\n")

%Obtain theta_ls
N = length(p2_u1);

theta_ls = zeros(5,1);

Phiy1_p2 = zeros(N,5);
Phiy1_p2(1,:) = [0,0,0,0,0];
Phiy1_p2(2,:) = [-p2_y1(1),0,0,p2_u1(1),0];
Phiy1_p2(3,:) = [-p2_y1(2),-p2_y1(1),0,p2_u1(2),p2_u1(1)];
for i = 4:N
    Phiy1_p2(i,:) = [-p2_y1(i-1),-p2_y1(i-2),-p2_y1(i-3),p2_u1(i-1),p2_u1(i-2)];
end

theta_ls(:,1) = Phiy1_p2\p2_y1;

%Define TFs
z = tf('z');
Aest = 1 + theta_ls(1)*z^(-1) + theta_ls(2)*z^(-2) + theta_ls(3)*z^(-3);
Best = theta_ls(4)*z^(-1) + theta_ls(5)*z^(-2);

%Obtain instrument
time = 0:1:N-1;
x = lsim(Best/Aest,p2_u2,time);

%Define new Phi with u2 and y2
Phiy2_p2 = zeros(N,5);
Phiy2_p2(1,:) = [0,0,0,0,0];
Phiy2_p2(2,:) = [-p2_y2(1),0,0,p2_u2(1),0];
Phiy2_p2(3,:) = [-p2_y2(2),-p2_y2(1),0,p2_u2(2),p2_u2(1)];
for i = 4:N
    Phiy2_p2(i,:) = [-p2_y2(i-1),-p2_y2(i-2),-p2_y2(i-3),p2_u2(i-1),p2_u2(i-2)];
end

% Form the regressor zeta for instrument
zeta = zeros(N,5);

zeta(1,:) = [0,0,0,0,0];
zeta(2,:) = [-x(1),0,0,p2_u2(1),0];
zeta(3,:) = [-x(2),-x(1),0,p2_u2(2),p2_u2(1)];
for j = 4:N
    zeta(j,:)=[-x(j-1),-x(j-2),-x(j-3),p2_u2(j-1),p2_u2(j-2)];
end

R = 0;
for k = 1:N
    R = R + 1/N * transpose(zeta(k,:))*Phiy2_p2(k,:);    
end

f = 1/N * transpose(zeta)*p2_y2;

theta_iv1 = R\f;



p2_a_ex1 = [theta_iv1(1),theta_iv1(2),theta_iv1(3)]';
p2_b_ex1 = [theta_iv1(4),theta_iv1(5)]';
%% Part 2
% Compute parameter estimates using delayed inputs as instruments

fprintf("------------------------------------------------------------------\n")
fprintf("------------------------------------------------------------------\n")
fprintf("\n")
fprintf("Task 2:\n")
fprintf("\n")

fprintf("The right number of delayed inputs is 5, since I want to estimate\n")
fprintf("5 parameters. This was specified during class by Prof Smith.\n")
fprintf("\n")
fprintf("Since the data of 2 experiments is given, I will append both Phi and\n")
fprintf("Zeta-matrixes to use Least Squares on more points.\n")
fprintf("I also tried estimating a theta for each experiment (1 and 2)\n")
fprintf("specifically and calculating the mean, but it performed worse.\n")
fprintf("\n")
fprintf("The new estimator has been computed exclusively with an instrumental\n")
fprintf("matrix made out of shifted inputs. In this case the estimator is as\n")
fprintf("before unbiased, since there is no noise-estimator correlation, but\n")
fprintf("in my opinion the estimator does not reflect the system structure\n")
fprintf("as good as the first estimator. It was chosen in a more arbitrary\n")
fprintf("way than estimator-matrix for Task 1 (where estimator-matrix comes\n")
fprintf("from the configuration of the model).\n")
fprintf("\n")


%APPROACH1: 2 experiments
%Experiment1
zeta_delay1(1,:) = [0,0,0,0,0];
zeta_delay1(2,:) = [p2_u1(1),0,0,0,0];
zeta_delay1(3,:) = [p2_u1(2),p2_u1(1),0,0,0];
zeta_delay1(4,:) = [p2_u1(3),p2_u1(2),p2_u1(1),0,0];
zeta_delay1(5,:) = [p2_u1(4),p2_u1(3),p2_u1(2),p2_u1(1),0];
zeta_delay1(6,:) = [p2_u1(5),p2_u1(4),p2_u1(3),p2_u1(2),p2_u1(1)];
for j = 7:N
    zeta_delay1(j,:)=[p2_u1(j-1),p2_u1(j-2),p2_u1(j-3),p2_u1(j-4),p2_u1(j-5)];
end

R_1 = 0;
for k = 1:N
    R_1 = R_1 + 1/N * transpose(zeta_delay1(k,:))*Phiy1_p2(k,:);    
end
f_1 = 1/N * transpose(zeta_delay1)*p2_y1;

theta_iv_2_1 = R_1\f_1;

%Experiment2
zeta_delay2(1,:) = [0,0,0,0,0];
zeta_delay2(2,:) = [p2_u2(1),0,0,0,0];
zeta_delay2(3,:) = [p2_u2(2),p2_u2(1),0,0,0];
zeta_delay2(4,:) = [p2_u2(3),p2_u2(2),p2_u2(1),0,0];
zeta_delay2(5,:) = [p2_u2(4),p2_u2(3),p2_u2(2),p2_u2(1),0];
zeta_delay2(6,:) = [p2_u2(5),p2_u2(4),p2_u2(3),p2_u2(2),p2_u2(1)];
for j = 7:N
    zeta_delay2(j,:)=[p2_u2(j-1),p2_u2(j-2),p2_u2(j-3),p2_u2(j-4),p2_u2(j-5)];
end

R_2 = 0;
for k = 1:N
    R_2 = R_2 + 1/N * transpose(zeta_delay2(k,:))*Phiy2_p2(k,:);    
end
f_2 = 1/N * transpose(zeta_delay2)*p2_y2;

theta_iv_2_2 = R_2\f_2;

theta_mean = (theta_iv_2_1 + theta_iv_2_2)./2;


%APPROACH2: Append zeta and phi
p2_y_merged = [p2_y1;p2_y2];
Phi_merged = [Phiy1_p2; Phiy2_p2];

zeta_merged = [zeta_delay1; zeta_delay2];
R_merged = 0;
for k = 1:2*N
    R_merged = R_merged + 1/(2*N) * transpose(zeta_merged(k,:))*Phi_merged(k,:);    
end
f_merged = 1/(2*N) * transpose(zeta_merged)*p2_y_merged;

theta_iv_merged = R_merged\f_merged;


p2_a_ex2 = [theta_iv_merged(1), theta_iv_merged(2), theta_iv_merged(3)]';
p2_b_ex2 = [theta_iv_merged(4), theta_iv_merged(5)]'; 
%% Part 3
% Compute mean squared errors using the cross-validation data set
fprintf("------------------------------------------------------------------\n")
fprintf("------------------------------------------------------------------\n")
fprintf("\n")
fprintf("Task 3:\n")
fprintf("\n")

fprintf("The first instrumental matrix takes into account that the system\n")
fprintf("has a 3rd order A(z) and a 2nd order B(z) transfer functions. So\n")
fprintf("even though the second estimate is also not noise-correlated (using\n")
fprintf("just past inputs), the first estimate will perform better (smaller\n")
fprintf("validation MSE).\n")
fprintf("\n")
fprintf("So that the estimator was the same, A(z)=1, so there is no dependence\n")
fprintf("on y-shifts (only delayed inputs).\n")
fprintf("Also, B(z) needs to have no common factors with A(z), as stated in\n")
fprintf("Exercise Set 9, Problem 1. That will always be the case for A(z)=1.\n")
fprintf("Additionally, the system structure (order of A(z) and B(z)) of the\n")
fprintf("model needs to match the real system's structure.\n")
fprintf("\n")


%Output for theta1
z = tf('z');
A_theta1 = tf([1 theta_iv1(1) theta_iv1(2) theta_iv1(3)], 1, 1, 'Variable', 'z^-1');
B_theta1 = tf([0 theta_iv1(4) theta_iv1(5)], 1, 1, 'Variable', 'z^-1'); 

y_theta_1 = lsim(B_theta1/A_theta1, p2_u_cv);

%Outputs for theta2
A_theta2 = tf([1 theta_mean(1) theta_mean(2) theta_mean(3)], 1, 1, 'Variable', 'z^-1');
B_theta2 = tf([0 theta_mean(4) theta_mean(5)], 1, 1, 'Variable', 'z^-1'); 

y_theta_2 = lsim(B_theta2/A_theta2, p2_u_cv);

%Outputs merged
A_theta_merged = tf([1 theta_iv_merged(1) theta_iv_merged(2) theta_iv_merged(3)], 1, 1, 'Variable', 'z^-1');
B_theta_merged = tf([0 theta_iv_merged(4) theta_iv_merged(5)], 1, 1, 'Variable', 'z^-1');

y_theta_merged = lsim(B_theta_merged/A_theta_merged, p2_u_cv);



mse1 = sum(1/N * (y_theta_1 - p2_y_cv).^2);
mse2 = sum(1/N * (y_theta_2 - p2_y_cv).^2);
mse_merged = sum(1/N * (y_theta_merged - p2_y_cv).^2);



p2_mse_ex1 = mse1; 
p2_mse_ex2 = mse_merged;
end

